"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addPinnedRow = addPinnedRow;
exports.removePinnedRow = removePinnedRow;
exports.useGridRowPinningPreProcessors = void 0;

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var React = _interopRequireWildcard(require("react"));

var _internals = require("@mui/x-data-grid/internals");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function addPinnedRow({
  groupingParams,
  rowModel,
  rowId,
  position,
  apiRef,
  isAutoGenerated
}) {
  var _groupingParams$addit;

  const idRowsLookup = (0, _extends2.default)({}, groupingParams.idRowsLookup);
  const tree = (0, _extends2.default)({}, groupingParams.tree); // TODO: warn if id is already present in `props.rows`

  idRowsLookup[rowId] = rowModel; // Do not push it to ids list so that pagination is not affected by pinned rows
  // ids.push(rowId);

  tree[rowId] = {
    id: rowId,
    isAutoGenerated,
    parent: null,
    depth: 0,
    groupingKey: null,
    groupingField: null,
    isPinned: true
  };
  apiRef.current.unstable_caches.rows.idRowsLookup[rowId] = (0, _extends2.default)({}, rowModel);
  apiRef.current.unstable_caches.rows.idToIdLookup[rowId] = rowId;
  const previousPinnedRows = ((_groupingParams$addit = groupingParams.additionalRowGroups) == null ? void 0 : _groupingParams$addit.pinnedRows) || {};
  const newPinnedRow = {
    id: rowId,
    model: rowModel
  };
  return (0, _extends2.default)({}, groupingParams, {
    idRowsLookup,
    tree,
    additionalRowGroups: (0, _extends2.default)({}, groupingParams.additionalRowGroups, {
      pinnedRows: (0, _extends2.default)({}, previousPinnedRows, {
        [position]: [...(previousPinnedRows[position] || []), newPinnedRow]
      })
    })
  });
}

function removePinnedRow({
  groupingParams,
  rowId,
  apiRef
}) {
  const idRowsLookup = (0, _extends2.default)({}, groupingParams.idRowsLookup);
  const tree = (0, _extends2.default)({}, groupingParams.tree);
  delete idRowsLookup[rowId];
  delete tree[rowId];
  delete apiRef.current.unstable_caches.rows.idRowsLookup[rowId];
  delete apiRef.current.unstable_caches.rows.idToIdLookup[rowId];
}

const useGridRowPinningPreProcessors = apiRef => {
  const previousPinnedRowsCacheRef = React.useRef(null);
  const addPinnedRows = React.useCallback(groupingParams => {
    var _pinnedRowsCache$topI, _pinnedRowsCache$bott;

    const pinnedRowsCache = apiRef.current.unstable_caches.pinnedRows || {};
    const previousPinnedRowsCache = previousPinnedRowsCacheRef.current;
    previousPinnedRowsCacheRef.current = pinnedRowsCache;
    let newGroupingParams = (0, _extends2.default)({}, groupingParams, {
      additionalRowGroups: (0, _extends2.default)({}, groupingParams.additionalRowGroups, {
        // reset pinned rows state
        pinnedRows: {}
      })
    });

    if (previousPinnedRowsCache) {
      var _previousPinnedRowsCa, _previousPinnedRowsCa2;

      (_previousPinnedRowsCa = previousPinnedRowsCache.topIds) == null ? void 0 : _previousPinnedRowsCa.forEach(rowId => {
        removePinnedRow({
          groupingParams: newGroupingParams,
          rowId,
          apiRef
        });
      });
      (_previousPinnedRowsCa2 = previousPinnedRowsCache.bottomIds) == null ? void 0 : _previousPinnedRowsCa2.forEach(rowId => {
        removePinnedRow({
          groupingParams: newGroupingParams,
          rowId,
          apiRef
        });
      });
    }

    (_pinnedRowsCache$topI = pinnedRowsCache.topIds) == null ? void 0 : _pinnedRowsCache$topI.forEach(rowId => {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId,
        position: 'top',
        apiRef,
        isAutoGenerated: false
      });
    });
    (_pinnedRowsCache$bott = pinnedRowsCache.bottomIds) == null ? void 0 : _pinnedRowsCache$bott.forEach(rowId => {
      newGroupingParams = addPinnedRow({
        groupingParams: newGroupingParams,
        rowModel: pinnedRowsCache.idLookup[rowId],
        rowId,
        position: 'bottom',
        apiRef,
        isAutoGenerated: false
      });
    }); // If row with the same `id` is present both in `rows` and `pinnedRows` - remove it from `ids`

    newGroupingParams.ids = newGroupingParams.ids.filter(rowId => {
      if (newGroupingParams.tree[rowId] && newGroupingParams.tree[rowId].isPinned) {
        return false;
      }

      return true;
    });
    return newGroupingParams;
  }, [apiRef]);
  (0, _internals.useGridRegisterPipeProcessor)(apiRef, 'hydrateRows', addPinnedRows);
};

exports.useGridRowPinningPreProcessors = useGridRowPinningPreProcessors;