import _extends from "@babel/runtime/helpers/extends";
import _defineProperty from "@babel/runtime/helpers/defineProperty";

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

import React, { useEffect, useRef, useState } from 'react';
import { defaultArgTypes as argTypes } from '@looker/storybook';
import { Button } from '../Button';
import { Card } from '../Card';
import { FieldToggleSwitch } from '../Form';
import { Space, SpaceVertical } from '../Layout';
import { Text } from '../Text';
import { Popover, PopoverContent } from '../Popover';
import { Tooltip } from './';

const Template = args => React.createElement(Tooltip, args, React.createElement(Button, {
  m: "xxxlarge"
}, "Open Tooltip"));

export const Basic = Template.bind({});
Basic.args = {
  content: 'Simple Content'
};
Basic.parameters = {
  storyshots: {
    disable: true
  }
};
export const Open = Template.bind({});
Open.args = _objectSpread(_objectSpread({}, Basic.args), {}, {
  isOpen: true
});
Open.parameters = {
  storyshots: {
    disable: true
  }
};
export const PlacemenTop = Template.bind({});
PlacemenTop.args = _objectSpread(_objectSpread({}, Basic.args), {}, {
  placement: 'top'
});
PlacemenTop.parameters = {
  storyshots: {
    disable: true
  }
};
export const PlacementRight = Template.bind({});
PlacementRight.args = _objectSpread(_objectSpread({}, Basic.args), {}, {
  placement: 'right'
});
PlacementRight.parameters = {
  storyshots: {
    disable: true
  }
};
export const PlacementLeft = Template.bind({});
PlacementLeft.args = _objectSpread(_objectSpread({}, Basic.args), {}, {
  content: 'Left',
  placement: 'left'
});
PlacementLeft.parameters = {
  storyshots: {
    disable: true
  }
};
export const DelayNone = Template.bind({});
DelayNone.args = _objectSpread(_objectSpread({}, Basic.args), {}, {
  delay: 'none'
});
DelayNone.parameters = {
  storyshots: {
    disable: true
  }
};
export const OpenDelayNone = Template.bind({});
OpenDelayNone.args = _objectSpread(_objectSpread({}, DelayNone.args), {}, {
  isOpen: true
});
OpenDelayNone.parameters = {
  storyshots: {
    disable: true
  }
};
export const RenderProp = () => React.createElement(Tooltip, {
  content: "Start editing",
  placement: "right"
}, tooltipProps => React.createElement(Button, _extends({
  m: "xxxlarge"
}, tooltipProps), "Open Tooltip"));
RenderProp.parameters = {
  storyshots: {
    disable: true
  }
};
export const LargeTrigger = () => React.createElement(Tooltip, {
  content: "See what happens when you scroll",
  placement: "right"
}, React.createElement(Card, {
  width: 500,
  height: 800,
  raised: true,
  p: "u5"
}, "Very large trigger"));
LargeTrigger.parameters = {
  storyshots: {
    disable: true
  }
};
export const NestedInPopover = () => {
  const [prevent, setPrevent] = useState(false);

  function handleChange(e) {
    setPrevent(e.currentTarget.checked);
  }

  const [lastEvent, setLastEvent] = useState('N/A');

  const getHandler = text => e => {
    setLastEvent(text);

    if (prevent) {
      e.preventDefault();
    }
  };

  const handlers = {
    onBlur: getHandler('blur'),
    onClick: getHandler('click'),
    onFocus: getHandler('focus'),
    onMouseOut: getHandler('mouse out'),
    onMouseOver: getHandler('mouse over')
  };
  return React.createElement(SpaceVertical, {
    p: "u5"
  }, React.createElement(Text, null, "Last event: ", lastEvent), React.createElement(Space, null, React.createElement(Popover, {
    content: React.createElement(PopoverContent, null, "Some content")
  }, React.createElement(Tooltip, {
    content: "Some tooltip"
  }, React.createElement(Button, handlers, "Open"))), React.createElement(FieldToggleSwitch, {
    on: prevent,
    onChange: handleChange,
    label: "Prevent default"
  })));
};
NestedInPopover.parameters = {
  storyshots: {
    disable: true
  }
};
export const PerformanceTest = () => {
  const [value, setValue] = useState('');

  const handleChange = e => setValue(e.currentTarget.value);

  const lastRenderRef = useRef(Date.now());
  useEffect(() => {
    const now = Date.now();
    const diff = now - lastRenderRef.current;
    console.log(diff);
    lastRenderRef.current = now;
  });
  return React.createElement("div", null, React.createElement("p", null, "Type fast then hold down delete:"), React.createElement("input", {
    type: "text",
    value: value,
    onChange: handleChange
  }), React.createElement("p", null, "The text shouldn't freeze due to main thread being blocked."), React.createElement("div", null, Array.from(Array(1000), (_, i) => React.createElement(Tooltip, {
    key: i,
    content: "I'm a tooltip"
  }, React.createElement("button", null, "Hover me")))));
};
PerformanceTest.parameters = {
  storyshots: {
    disable: true
  }
};
export default {
  argTypes,
  component: Tooltip,
  title: 'Tooltip'
};
//# sourceMappingURL=Tooltip.stories.js.map